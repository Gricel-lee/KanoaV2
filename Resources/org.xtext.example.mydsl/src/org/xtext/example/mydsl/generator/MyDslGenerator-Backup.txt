package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import dsl.AtomicTask
import dsl.CompoundTask
import java.util.ArrayList
import dsl.MissionTask
import dsl.TaskTime
import java.util.Hashtable
import java.util.List
import dsl.Location

/** Create global variables */
 class GlobalVar {
   /** Counter for instances of atomic tasks*/
   public int countATpython = 0
   /** Counter for instances of compound tasks*/
   public int countCTpython = 0
   /** Header for the Task Tree file*/
   public String dbTaskTree = "id,,parent,,ordered_children,,location,,numrobots,,joint,,ordered,,consecutive,,start,,end"; 
   /** List of start task time constraints*/
   public Hashtable<String, Double> startTime = new Hashtable();
   /** List of end task time constraints*/
   public Hashtable<String, Double> endTime = new Hashtable();
   
   /** List atomic tasks locations*/
   public Hashtable<AtomicTask, Location> atLoc = new Hashtable();
   
   /**List of atomic tasks needed for the mission */
   public List<AtomicTask> at_missions = new ArrayList();
   /**fsa */
   public IFileSystemAccess2 fsa;
   
   
   def setFsa(IFileSystemAccess2 fsa){
   	this.fsa = fsa
   }
   
   /** Reset variables */
   def reset(){
   	countATpython = 0
   	countCTpython = 0
   	dbTaskTree = "id,,parent,,ordered_children,,location,,numrobots,,joint,,ordered,,consecutive";
   	startTime = new Hashtable();
	endTime = new Hashtable();
	atLoc = new Hashtable();
   }
		
   /** Get list of initial and end tasks' time constraints */
	def checkEndStartTimes(Resource resource) {
		// list of task time constraints
		var ttimeList = resource.allContents.filter(TaskTime);
		var tID = ""
		while(ttimeList.hasNext()) {
			//task time constraint
			val tt = ttimeList.next();
			//get task id
			if (tt.at!==null){tID=tt.at.name}
			else if (tt.ct!==null){ tID=tt.ct.name }
			else if (tt.mt!==null){ tID=tt.mt.name }
			// save as start or end
			if (tt.startEnd.toString()=="start"){ this.startTime.put(tID,tt.time) }
			if (tt.startEnd.toString()=="end"){ this.endTime.put(tID,tt.time)}
			//println("Task: "+ tt); println("has " + tt.startEnd + tt.time.toString())
		}
	}
}





/**Tasks tree - extract information from DSL*/
class Tree{
	
	/** Create Global variables */
	public val GlobalVar gv = new GlobalVar()
	
	/** Create tree */
	def createTree(Resource resource, IFileSystemAccess2 fsa){
		gv.fsa = fsa;
		// 1 get tasks constraints
		gv.checkEndStartTimes(resource)
		// 2 mission tasks
		val mtList = resource.allContents.filter(MissionTask);
		while(mtList.hasNext()) {
			// mission i
			val m = mtList.next();
			println("\nGetting mission:" + m.name );
			switch m{
				MissionTask:{
					var loc = m.loc
					var location = ""
					//-- Get location
					// task mission with location
					if (loc !== null){location = m.loc.name}
					// task mission with NO location
					else{location = "NaN"}
					
					//-- Get child
					var childStr = ""
					var start = "null"
					var end = "null"
					if (m.ct !== null){ //compound task
						gv.countCTpython += 1
						childStr = " [\'" + m.ct.name + "_" + gv.countCTpython +"\']"
						//-- Save mission -missionTreeString(id, par, child, location, numrobots, joint, order , consec, endTime, startTime)
						gv.dbTaskTree += missionTreeString(m.name, "NaN", childStr , "NaN", "NaN", "NaN", "NaN" , "NaN", "null", "null")  //missions have no location
						
						//--Get constraints
						if (gv.startTime.containsKey(m.name)){start=gv.startTime.get(m.name).toString()}
						if (gv.endTime.containsKey(m.name)){end=gv.endTime.get(m.name).toString()}
						
						//-- Recursive save subtasks - (parent id, task, task instance, location, start, end)
						recursiveGetSubTasks(m.name,m.ct,gv.countCTpython,location, start, end);
					}
					else if (m.at !== null){ //atomic task
						
						childStr = " [\'" + m.at.name + "_" + gv.countATpython +"\']"
						//-- Save mission -missionTreeString(id, par, child, location, numrobots, joint, order , consec, endTime, startTime)
						gv.dbTaskTree += missionTreeString(m.name, "NaN", childStr , "NaN", "NaN", "NaN", "NaN" , "NaN", "null", "null") //missions have no location
						
						//-- Save atomic task
						var atName = m.at.name + "_" + gv.countATpython; //atomic task instance
						if (location=="NaN"){ location = m.at.loc.name} // location: if mission not have location, use location of atomic task
						var joint = "false"; if(m.at.robots>1){joint="true"}
						
						gv.atLoc.put(m.at,m.at.loc) 
						
						//--Get constraints
						//for start
						if (gv.startTime.containsKey(m.name)){start=gv.startTime.get(m.name).toString()}
						else if (gv.startTime.containsKey(m.at.name)){start=gv.startTime.get(m.at.name).toString()}
						//for end
						if (gv.endTime.containsKey(m.name)){end=gv.endTime.get(m.name).toString()}
						else if (gv.endTime.containsKey(m.at.name)){end=gv.endTime.get(m.at.name).toString()}
						
						gv.dbTaskTree += missionTreeString(atName, m.name, "NaN" , location, m.at.robots.toString(), joint, "NaN" , "NaN", start, end)
						
					}
					else
						throw new UnsupportedOperationException("ERROR - no compound or atomic task found in mission task")	
				}
			}
		}
	}
	
	
	
	/**Recursive save subtasks - (parent id, task, task count instance, location, start, end constraints) */
	def void recursiveGetSubTasks(String parentId, CompoundTask task, int i, String loc, String start, String end) {
		
		//--1 subtasks string
		var subtasks_id = new ArrayList();
		
		for (t:task.canDoTask){ // subtasks
			switch t{
				AtomicTask:{subtasks_id.add(t.name +"_"+ gv.countATpython+1) }
				CompoundTask:{subtasks_id.add(t.name +"_"+ gv.countCTpython+1)} } }
		var ctName = task.name + "_" + i; // name instantiated
		
		//-- 2 Save -missionTreeString(id, par, child, location, numrobots, joint, order , consec, endTime, startTime)
		gv.dbTaskTree += missionTreeString(ctName, parentId, '[\''+subtasks_id.join('\',\'')+'\']' , "NaN", "NaN", "NaN", task.ordered.toString() , task.consecutive.toString(), "null", "null") //CT has no location, no task constraints
		
		//-- 4 Recursive add subtasks
		for (t:task.canDoTask){
			switch t{
				AtomicTask:{
					//-- a1 Get info
					gv.at_missions.add(t) 	 //add to list of necessary atomic tasks
					gv.countATpython += 1
					var atName = t.name + "_" + gv.countATpython; //task instance
					var location = loc; if (loc=="NaN"){ location = t.loc.name} // location: if mission not have location, use location of atomic task
					var joint = "false"; if(t.robots>1){joint="true"}
					gv.atLoc.put(t,t.loc) 
					//-- a1.1 start time constraints
					var start1 = "null"
					//if parent has constraint
					if (start!=="null"){start1=start}
					//if parent has no constraint
					else if (start==="null"){ //check if task is constrained
						if (gv.startTime.containsKey(t.name)){start1=gv.startTime.get(t.name).toString() }
					}
					//-- a1.2 end time constraints
					var end1 = "null"
					//if parent has constraint
					if (end!=="null"){end1=end}
					//if parent has no constraint
					else if (end==="null"){ //check if task is constrained
						if (gv.endTime.containsKey(t.name)){end1=gv.endTime.get(t.name).toString() }
					}
					
					//-- Save -missionTreeString(id, par, child, location, numrobots, joint, order , consec, endTime, startTime)
					gv.dbTaskTree += missionTreeString(atName, ctName, "NaN" , location, t.robots.toString(), joint, "NaN", "NaN", end1, start1) //CT has no location

				}
				CompoundTask:{
					//-- a1.1 start time constraints
					var start1 = "null"
					//if parent has constraint
					if (start!=="null"){start1=start}
					//if parent has no constraint
					else if (start==="null"){ //check if task is constrained
						if (gv.startTime.containsKey(t.name)){start1=gv.startTime.get(t.name).toString() }
					}
					//-- a1.2 end time constraints
					var end1 = "null"
					//if parent has constraint
					if (end!=="null"){end1=end}
					//if parent has no constraint
					else if (end==="null"){ //check if task is constrained
						if (gv.endTime.containsKey(t.name)){end1=gv.endTime.get(t.name).toString() }
					}
					
					// --recursivelly add to database (parent id, task, task count instance, location)
					gv.countCTpython += 1
					recursiveGetSubTasks(ctName, t, gv.countCTpython, loc, start1, end1);
					
				}
			}
		}		
	}
	
	
	
	
	
	/** Row in .txt file used for a dataframe df in python */
	def static missionTreeString(String id, String par, String child,
	 String location, String numrobots, String joint,
	 String order , String consec, String end , String start){
	 	// .replaceAll("\\s+","") removes white spaces
	 	
	 	var separator = ",,"
		var dfAllocationLine = "\n"+ 
		id.replaceAll("\\s+","") + separator +
		par.replaceAll("\\s+","") + separator +
		child.replaceAll("\\s+","")+ separator +
		location.replaceAll("\\s+","") + separator +
		numrobots.replaceAll("\\s+","")+ separator +
		joint.replaceAll("\\s+","") + separator +
		order.replaceAll("\\s+","") + separator +
		consec.replaceAll("\\s+","") + separator +
		end.replaceAll("\\s+","") + separator +
		start.replaceAll("\\s+","")
		return dfAllocationLine
	}
	
	
	/** Generate tree file*/
	def generateTreeFile(String fileName){
		gv.fsa.deleteFile(fileName);
		this.generateFile(fileName, gv.dbTaskTree)
	}
	
	def generateFile(String fileName, String finalString){
		gv.fsa.deleteFile(fileName);
		gv.fsa.generateFile(fileName, finalString)
	}
}

