'''
This file contains generic functions required through out the project.

Author: Gricel Vazquez 31/03/2022
'''

import os
import glob
import sys
from collections import OrderedDict

def getAlloyXMLpaths(mypath):
    '''
    Get all .xml files paths
    Input: files path
    '''
    # sorted files
    listXMLFiles = sorted(glob.glob(mypath), key=lambda name: int(''.join(filter(str.isdigit,name))))
    
    #not sorted
    #listXMLFiles = glob.glob(mypath)
    
    #print(listXMLFiles) #Print paths of files .xml
    return(listXMLFiles)

def getNum_Alloyfile(file):
    '''
    Get number of allocation .xml file generated by Alloy Analyzer
    '''
    if "\\" in file:
            num = file.split('\\')[-1].replace('Alloyallocation','').replace('.xml','') # x number of "AlloyinstanceX.xml" file 
    else:
        num = file.split('/')[-1].replace('Alloyallocation','').replace('.xml','') # x number of "AlloyinstanceX.xml" file
    return num

import shutil     
def create_empty_folder(filename):
    if os.path.exists(os.path.dirname(filename)):
        try:
            shutil.rmtree(filename)
        except:
            print("ERROR creating empty folder: ",filename)
            raise
    create_folder_if_not_exist(filename)

def create_folder_if_not_exist(filename):
    '''Create folder for file, if path do not exists.'''
    
    if not os.path.exists(os.path.dirname(filename)):
        try:
            os.makedirs(filename, exist_ok=True)  #argument exist_ok=True to create folder if not exists
        except:
            try:
                os.makedirs(os.path.dirname(filename))
            except:
                print("ERROR creating empty folder: ",filename)
                raise
    

# DEPRICATED
#def get_task_generic_fromAllocation(r,at):
#    s = "_"
#    return at.split(s,-1)[0]
       
def get_generic_task(at):
    return at.rsplit("_",1)[0]

def create_folder_abs_if_not_exist(path):
    '''Create folder, if path do not exists.'''
    if not os.path.exists(os.path.abspath(path)):
        try:
            os.makedirs(os.path.abspath(path), exist_ok=True)
        except:
            print("ERROR creating folder " ,path)
            raise

def printRow(df,header,value):
    '''Example on how to print a row where header is equal to value'''
    print(df.loc[df[header]==value].astype(str).values.flatten().tolist())
    

def _get_list_of_robots(dfAllocation):
    # get list of robots
    r_list = []
    for i in dfAllocation['runbyrobot']:
        try: #if has robots (i.e., atomic task)
            r_list += eval(i)
        except: # if no robot   
            pass
    # delete duplicate robots
    return(list(OrderedDict((x, True) for x in r_list).keys())) # e.g.:  ['r4$0', 'r3$0', 'r2$0']



def getRobot(at,a):
    '''Get robots of an atomic task'''
    return eval(a.dfAllocation[a.dfAllocation['id']==at]['runbyrobot'].values.item())

def rename(r,t):
    '''rename task with robot id at the beginning + _'''
    return r+"_"+t


########## DEPRICATED NAME: def isConstrained, now getConstrainedTasks 
def isConstrained(consecutive,ordered,dfAllocation):
    '''Get compound tasks consec/order constrained
    input combinations: (not) ordered / (not) consecutive, e.g.: 
    consecutive = False      #must be ==True/False otherwise detects NaN as well
    ordered = True           #must be ==True/False otherwise detects NaN as well
    '''
    # filter tasks
    df = dfAllocation.loc[dfAllocation['consecutive']==consecutive] 
    df = df.loc[df['ordered']==ordered]
    df = df.loc[df['joint'].isnull()] # For further refinement: this is added as there is an error in the generation of atomic tasks in the allocationInfo.csv file. They contain info in columns: consecutive and ordered
    #print('filtered tasks: ',df)
    return df
############



def isJoin(dfAllocation,t):
    '''Check if a task is a join task'''
    try:
        # boolean saying if join task or not
        v = dfAllocation.loc[dfAllocation['id'] == t]['joint'].values.item() # to get one value
        #print('v: ',v,type(v))
    except:
        raise RuntimeError("Error in checkIfJoin with task ",t,". Maybe repeated task id in modelMissionsTree.txt")
    else:
        return v

###### Depricated and not working #### Moved to class constrainedTask
def getCT_all_ATsubtasks(ct,dfAllocation):
    '''Get all necessary atomic tasks for a compound task, recursively'''
    return
    


def flush_sys_streams() -> None:
    """
    flushes the output streams.

    flush calls are wrapped in try ... except, because 
    standard streams might be replaced with other streams which 
    dont have the flush method.
    https://stackoverflow.com/questions/63254323/python-loop-keeps-stopping-in-windows-interpreter
    """
    try:
        sys.stdout.flush()
    except Exception:
        pass
    try:
        sys.stderr.flush()
    except Exception:
        pass
    


'''NOTES no needed
children = dfAllocation.loc[dfAllocation['id']==tid]['ordered_children'].values.tolist()
    print('1children: ',children,type(children))
    children = dfAllocation.loc[dfAllocation['id']==tid]['ordered_children'].item()
    print('2children: ',children,type(children))
    children = dfAllocation.loc[dfAllocation['id']==tid]['ordered_children']
    print('3children: ',children,type(children))
    children = dfAllocation.loc[dfAllocation['id']==tid]['ordered_children'].items
    print('4children: ',children,type(children))
    children = dfAllocation.loc[dfAllocation['id']==tid].ordered_children.tolist()
    print('5children: ',children,type(children))
    children = dfAllocation.loc[dfAllocation['id']==tid].ordered_children
    print('6children: ',children,type(children))
    v = dfAllocation.loc[dfAllocation['id']==id]['ordered_children'].values.size
    ----- This worked as the item is a list fetched as a string, then eval converts it again to a list
    children = eval(dfAllocation.loc[dfAllocation['id']==tid]['ordered_children'].item())
    print('7children: ',children,type(children))
    ----- This worked to check if not null (or .isnull) 
    pd.notnull( df.loc[df['id']==t,'runbyrobot'].item() )
    
    
    
    The second requires less time:
    repoList = df.uniqueAlloc.values.tolist()
    print(time.process_time() - start) # 1
    print(repoList)
    
    start = time.process_time()
    repoList = df['uniqueAlloc'].tolist() # 2
'''
